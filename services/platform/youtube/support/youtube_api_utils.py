import os

from datetime import datetime
from rich.status import Status
from rich.console import Console
from dotenv import load_dotenv
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import List, Dict, Any, Optional

console = Console()

def _log(message: str, verbose: bool = False, is_error: bool = False, status: Optional[Status] = None):
    timestamp = datetime.now().strftime("%H:%M:%S")
    
    if is_error:
        level = "ERROR"
        style = "bold red"
    else:
        level = "INFO"
        style = "white"
    
    formatted_message = f"[{timestamp}] [{level}] {message}"
    
    if verbose or is_error:
        console.print(formatted_message, style=style)
    
    if status:
        status.update(formatted_message)

def initialize_youtube_api(profile_name: str, verbose: bool = False) -> Optional[Any]:
    service_account_file = "credentials/service_account.json"
    
    if not os.path.exists(service_account_file):
        _log(f"Service account file not found at {service_account_file}. YouTube API cannot be initialized.", verbose, is_error=True)
        return None

    try:
        credentials = service_account.Credentials.from_service_account_file(
            service_account_file,
            scopes=["https://www.googleapis.com/auth/youtube.force-ssl"]
        )
        service = build("youtube", "v3", credentials=credentials)
        _log("YouTube API initialized successfully using service account.", verbose)
        return service
    except Exception as e:
        _log(f"Error initializing YouTube API with service account: {e}", verbose, is_error=True)
        return None

def list_caption_tracks(profile_name: str, youtube_service: Any, video_id: str, status: Optional[Status] = None, verbose: bool = False) -> List[Dict[str, Any]]:
    caption_tracks = []

    try:
        _log(f"Listing caption tracks for video ID: {video_id}", verbose, status=status)
        
        request = youtube_service.captions().list(
            part="id,snippet",
            videoId=video_id
        )
        response = request.execute()
        
        for item in response.get("items", []):
            caption_tracks.append({
                "id": item["id"],
                "language": item["snippet"]["language"],
                "name": item["snippet"]["name"],
                "track_kind": item["snippet"]["trackKind"],
                "is_auto_generated": item["snippet"].get("isAutoGenerated", False)
            })
        _log(f"Found {len(caption_tracks)} caption tracks for video ID {video_id}.", verbose, status=status)
    except Exception as e:
        _log(f"Unexpected error listing caption tracks for video ID {video_id}: {repr(e)}", verbose, is_error=True, status=status)
    
    return caption_tracks

def download_caption_track(profile_name: str, youtube_service: Any, caption_id: str, output_path: str, tfmt: str = "srt", tlang: Optional[str] = None, status: Optional[Status] = None, verbose: bool = False) -> bool:
    try:
        _log(f"Downloading caption track {caption_id} to {output_path}", verbose, status=status)
        
        request = youtube_service.captions().download(
            id=caption_id,
            tfmt=tfmt,
            tlang=tlang
        )
        
        response = request.execute()
        
        with open(output_path, "wb") as f:
            f.write(response)
            
        _log(f"Successfully downloaded caption track {caption_id}.", verbose, status=status)
        return True
    except Exception as e:
        _log(f"Unexpected error downloading caption track {caption_id}: {repr(e)}", verbose, is_error=True, status=status)
        return False
